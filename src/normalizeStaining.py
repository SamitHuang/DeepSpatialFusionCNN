# Autogenerated with SMOP version 
# main.py normalizeStaining.m
from __future__ import division
import numpy as np

def normalizeStaining(I=None):

    #I = np.asarray(Image.open('example1.tif'),dtype=np.float64);
    #if not exist(char('Io'),char('var')) or isempty(Io):
    Io=240
    #if not exist(char('beta'),char('var')) or isempty(beta):
    beta=0.15
    #if not exist(char('alpha'),char('var')) or isempty(alpha):
    alpha=1
    #if not exist(char('HERef'),char('var')) or isempty(HERef):
    #HERef=matlabarray(cat(0.5626,0.2159,0.7201,0.8012,0.4062,0.5581))
    HERef = np.array([[0.5626,0.2159],[0.7201,0.8012],[0.4062,0.5581]])
    #if not exist(char('maxCRef)'),char('var')) or isempty(maxCRef):
    #maxCRef=matlabarray(cat(1.9705,1.0308))
    maxCRef = np.array([1.9705,1.0308])
    
    (h,w,c) = np.shape(I)
    #h=size(I,1)
    #w=size(I,2)
    #I=double(I)
    I=np.reshape(I,(h*w,c),order='F')
    OD =- np.log((I + 1) / Io)
    ODhat=(OD[(np.logical_not((OD < beta).any(axis=1))),:])
    #V,__=eig(cov(ODhat),nargout=2)
    (W,V) = np.linalg.eig(np.cov(ODhat,rowvar=0))
    
    Vec =- np.transpose(np.array([V[:,1],V[:,0]])) #desnecessario o sinal negativo
    That=np.dot(ODhat,Vec)
    phi=np.arctan2(That[:,1],That[:,0])
    minPhi=np.percentile(phi,alpha)
    maxPhi=np.percentile(phi,100 - alpha)
    vMin = np.dot(Vec, np.array([np.cos(minPhi),np.sin(minPhi)]))
    vMax = np.dot(Vec, np.array([np.cos(maxPhi),np.sin(maxPhi)]))
    if vMin[0] > vMax[0]:
        HE=np.array([vMin,vMax])
    else:
        HE=np.array([vMax,vMin])
    
    HE = np.transpose(HE)    
    Y = np.transpose(np.reshape(OD,(h*w,c)))
    #
    #    print(np.shape(HE))
    #    print(np.shape(Y))
    
    
    C=np.linalg.lstsq(HE,Y)
    maxC=np.percentile(C[0],99,axis=1)
    
    #C=bsxfun(rdivide,C,maxC)
    C =  C[0]/maxC[:,None]
    #C=bsxfun(times,C,maxCRef)
    C = C*maxCRef[:,None]
    Inorm = Io * np.exp(- np.dot(HERef,C))
    Inorm = np.reshape(np.transpose(Inorm),(h,w,c),order='F')
    Inorm = np.clip(Inorm,0,255);
    Inorm = np.array(Inorm, dtype=np.uint8)
#    if nargout > 1:
#        H=Io * exp(- HERef[:,1] * C[1,:])
#        H=reshape(H.T,h,w,3)
#        H=uint8(H)
#    if nargout > 2:
#        E=Io * exp(- HERef[:,2] * C[2,:])
#        E=reshape(E.T,h,w,3)
#        E=uint8(E)
    return Inorm #,H,E
